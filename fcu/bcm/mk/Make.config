
ALOWED_MAKE_VERSIONS :=3.81 3.82

ifeq ($(filter $(ALOWED_MAKE_VERSIONS),$(MAKE_VERSION)),)
$(error Make $(MAKE_VERSION) not supported, use one of $(ALOWED_MAKE_VERSIONS))
endif




#
# Set a default target if one is not set. If override-target is set,
# then the target will become override-target and a warning is printed
# if the assigned TARGET was different.
#
ifneq ($(strip $(override-target)),)
override TARGET=$(override-target)
endif

#
# If TARGET is not set, default to a Unix target based on host type
#
ifndef TARGET
 uname := $(shell uname -s)
 ifeq ($(filter-out Linux Darwin,$(uname)),)
  ifeq ($(shell uname -m),x86_64)
   TARGET=linuxuser64
  else
   TARGET=linuxuser
  endif
 endif
 ifeq ($(uname),SunOS)
  TARGET=linuxuser.solaris
 endif
 ifeq ($(uname),NetBSD)
  TARGET=linuxuser.netbsd
 endif
 ifndef	TARGET
  $(error Cannot determine TARGET in Make.config, uname = $(uname))
 endif
endif

export TARGET


#
# Set up the target name, and the target base variables.
#
# target = The full name of the target such as vxworks-bmw
# targetbase = 1st part of target (e.g. vxworks) {linuxkern, linuxuser, vxworks}
# targetplat = 2nd part of target (e.g. x86) if any; otherwise same as 1st,
#
target     = ${TARGET}
targetsplt = $(subst ., , ${target})	# change hyphens to spaces
targetbase = $(word 1,${targetsplt})
targetplat = $(subst ${targetbase}.,,${TARGET})
#targetplat = $(lastword ,${targetsplt})

#$(warning "TARGET=$(TARGET),targetbase=$(targetbase),targetplat=$(targetplat), platform=$(platform)")
#
# Common configuration for all platforms
# (Additional platform-dependent configurations are in Makefile.xxx)
#

#
# THIS FILE SHOULD NOT BE MODIFIED LOCALLY, to override, add a file
# $SDK/mk/Make.var that sets your local settings, and/or provide
# a path to your settings using the MAKE_VAR variable.  If 
# either of these files exists, their values will override those in this makefile.
#
ifdef MAKE_VAR
include        ${MAKE_VAR}
else
-include	${SDK}/mk/Make.var
endif


# Required until regsfiles are pruned from mcm
CFGFLAGS += -DXXXXXXX

#
# By default, turn off the "changing directory" message.
#

MAKEFLAGS += --no-print-directory

#
# Use gmake by default
#

include ${SDK}/mk/Make.tools
include	${SDK}/mk/Makefile.${target}

# For make v3.80, eval function can't be placed inside any ifxxx-endif section
# The bug is fixed in v3.81
eval_fixed_ver := 3.81
eval_fixed := $(filter $(eval_fixed_ver),$(firstword $(sort $(MAKE_VERSION) $(eval_fixed_ver))))



QUIET ?= 1
# use QUIET=1 to control printing of compilation lines
ifeq (0,$(QUIET))
Q:=
else
Q:=@
endif

#
# Suffix to add to the "target" files to allow local builds with different
# flags. Set "target_suffix" to XXX to cause the build to put built objects
# in ${target}${target_suffix}. This allows things like building a debug
# version with different flags.  This may also be set in another Makefile.
#

#target_suffix :=

#
# Optional suffix to add to the build directory and output binary files
# to allow multiple builds to co-exist for various reasons.
#
#chip_suffix := -$(shell echo $(CHIP) | tr A-Z a-z)

#
# Combined suffixes
#
all_suffix = ${chip_suffix}${target_suffix}

#
# Default location to place binaries and make depend files for building
# purposes.
#
ifeq "$(HOSTTYPE)" "Windows2000PC"
BLDROOTWITHDRIVE = ${SDK}/build/${target}${all_suffix}${bldroot_suffix}
BLDROOT = ${SDK_NO_DRIVE_NAME}/build/${target}${all_suffix}${bldroot_suffix}
else # ifeq "$(HOSTTYPE)" "Windows2000PC"

ifndef SDKBUILD
SDKBUILD :=build
endif

BLDROOT = ${SDK}/${SDKBUILD}/$(if ${BLDCONFIG},${BLDCONFIG}/)${target}.${all_suffix}${bldroot_suffix}

$(warnning target=$(target),all_suffix=$(all_suffix),bldroot_suffix=$(bldroot_suffix))
endif # ifeq "$(HOSTTYPE)" "Windows2000PC"

# This is needed because we cannot include Make.vxworks before Make.config
ifndef DEST_DIR_SUFFIX
export DEST_DIR_SUFFIX :=$(subst $(realpath $(SDK))/app,,$(realpath $(CURDIR)/$(dir ($(firstword $(MAKEFILE_LIST))))))
ifeq ($(MAKELEVEL),0)
endif
endif

ifeq ($(DEST_DIR),)
export DEST_DIR :=${SDK}/${SDKBUILD}$(if ${BLDCONFIG},/${BLDCONFIG})$(DEST_DIR_SUFFIX)
endif

ifdef LOCALDIR
BLDDIR = ${BLDROOT}/${LOCALDIR}
ifeq "$(HOSTTYPE)" "Windows2000PC"
BLDDIRWITHDRIVE = ${BLDROOTWITHDRIVE}/${LOCALDIR}
endif
else # ifdef LOCALDIR
BLDDIR = ${BLDROOT}
ifeq "$(HOSTTYPE)" "Windows2000PC"
BLDDIRWITHDRIVE = ${BLDROOTWITHDRIVE}
endif
endif # ifdef LOCALDIR

LIBDIR = ${BLDROOT}

#
# Export directory, where build objects used by the outside world are
# placed (exported header files, libs, bins)
#
EXPDIR = ${SDK}/export/${target}${all_suffix}





#
# Paths of where we install files for make install
#
# install_headers - where to install header files.
# install_lib     - where to install libs
# install_bin	  - where to install completely linked binaries
#
install_headers	= ${SDK}/export/include
install_lib	= ${SDK}/export/lib/${target}
install_bin	= ${SDK}/export/bin/${target}

#
# Compilation Flags
#
# Flags may be added to (see below)
#

INCFLAGS = -I${SDK}/header -I${SDK}/app

CFLAGS += ${INCFLAGS}
CXXFLAGS += ${INCFLAGS}
CPPFLAGS += ${INCFLAGS}





ifeq ($(DEBUG_SYMBOLS),TRUE)
CFLAGS += -g
CXXFLAGS += -g
CPPFLAGS += -g
endif



#
# If DEBUG_CFLAGS is set, add its contents to CFLAGS.
# May be useful for setting on the command line or adding to Make.var.
# Example: gmake DEBUG_CFLAGS=-save-temps system.c
#

ifneq ($(DEBUG_CFLAGS),)
CFLAGS += $(DEBUG_CFLAGS)
CXXFLAGS += $(DEBUG_CFLAGS)
CPPFLAGS += $(DEBUG_CFLAGS)
endif

#
# Optimization level
#
# Set DEBUG_OPTIMIZE to TRUE (default) to use a normal optimization
#		determined by OPTFLAGS_DEFAULT in the platform Makefile.
# Set DEBUG_OPTIMIZE to FALSE to use no optimization,
#		strongly recommended when using any debugger.
# Set DEBUG_OPTIMIZE to any other option string to request specific
#		optimization flags (for example -O2).
#
ifndef DEBUG_OPTIMIZE
DEBUG_OPTIMIZE=TRUE
endif

ifeq ($(DEBUG_OPTIMIZE),TRUE)
OPTFLAGS += $(OPTFLAGS_DEFAULT)
else
ifneq ($(DEBUG_OPTIMIZE),FALSE)
OPTFLAGS += $(DEBUG_OPTIMIZE)
endif
endif

#
# Debug assertion control.
#
# Compiling out assert() saves about 1.1% on executable size,
# however doing so is VERY MUCH discouraged.
#
ifndef DEBUG_ASSERTS
DEBUG_ASSERTS=TRUE
endif

ifeq ($(DEBUG_ASSERTS),FALSE)
CFLAGS += -DNDEBUG
CXXFLAGS += -DNDEBUG
CPPFLAGS += -DNDEBUG
endif

#
# GCC pedantic mode.
#
ifeq ($(DEBUG_PEDANTIC),TRUE)
CFGFLAGS += -D__PEDANTIC__
CFLAGS += --pedantic
CXXFLAGS += --pedantic
endif

#
# In each directory, build a list of local sources, objects, and headers
#
LSRCS	=	$(wildcard *.c *.cpp *.s *.cc *.C)
LOBJS	=	$(addsuffix .o, $(basename ${LSRCS}))
BOBJS	= 	$(addprefix ${BLDDIR}/,${LOBJS})
LHDRS	=	$(wildcard *.h *.H)
LDOTIS	=	$(wildcard *.i)


ifeq ($(TOOLS),Borland)
BORLAND_LOBJS	=	$(addsuffix .obj, $(basename ${LSRCS}))
#BORLAND_BLDDIR	= 	$(subst, \,/, $(subst -,_,$(BLDDIR)))
BORLAND_BLDDIR	= 	$(BLDDIR)
BORLAND_BOBJS	= 	$(addprefix ${BORLAND_BLDDIR}/,${BORLAND_LOBJS})
endif

#
# Rule to create object file (build) directory
#

.PHONY: all install clean distclean

.PRECIOUS: ${BLDDIR}/.tree

%/.tree:
	@$(ECHO) MKDIR $(dir $@)
	$Q($(MKDIR) $(dir $@); $(TOUCH) $@)

# Rule allowing build through CPP only, creates .E file from .c file.

%.E: %.c
	$Q$(CC) -E ${CFLAGS} $< | $(SED) -e '/^ *$$/d' -e p -e d > $@

# Rule allowing build through source only, creates .s file from .c file.

%.s: %.c
	$Q$(CC) -S ${CFLAGS} $<

# allow disabling of dependency file generation
# enable partial recompilation through use of included
# dependency make files
#
ifndef NO_SDK_DEPS
# take the compiler generated .d file and reparse it 
# to generate a dependency graph rule for this object
# file
# the two steps generate:
#  file.o: file.c \
#	file.h ...
#
#  file.h: 
#  header.h: 
# some compilers will generate errors without the latter
# part of the list

.PHONY: .phony

DEPS_SED = \
	$(CP) $(BLDDIR)/$*.d $(BLDDIR)/$*.tmp;\
	$(ECHO) >> $(BLDDIR)/$*.tmp;\
	$(SED) -e 's/\#.*//' -e 's/^[^:]*: *//' \
	-e 's/ *\\$$//' -e '/^$$/ d' -e 's/$$/ :/' \
	-e '/^ .$$/d' \
	< $(BLDDIR)/$*.d >> $(BLDDIR)/$*.tmp; \
	$(SED) -e 's|^\([^\/ ].*\.o\):|'$(BLDDIR)/'\1:|g'  \
	-e 's|.*?/\(.*\.o\):|'$(BLDDIR)/'\1:|g'  \
	< $(BLDDIR)/$*.tmp > $(BLDDIR)/$*.P; \
	$(RM) -f $(BLDDIR)/$*.d $(BLDDIR)/$*.tmp
DEPS_CMD = $(DEPS_SED)

ifeq ($(targetbase),ghs)
DEPS_CMD = $(DEPS_SED)
else
ifeq ($(VX_VERSION),55)
# this supports the tornado 2.x.x compiler
# (VxWorks 5.x)
DEPS_CMD = $(DEPS_SED)
else
ifneq ($(findstring gnu,$(TOOL)),)
# Gnu compilers always support -MD -MF
DEPS_OPT = -MD -MF $(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
else
ifneq (,$(filter 64 65,$(VX_VERSION)))
BCM_CFLAGS = -Xstop-on-warning -Xlint
DEPS_OPT = -Xmake-dependency=4 -Xmake-dependency-savefile=$(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
else
ifneq ($(findstring i686,$(CROSS_COMPILE)),)
# Gcc 2.95 does not support -MD -MF with -o and -c
else
# newer gnu-based compilers allow -MD -MF
DEPS_OPT = -MD -MF $(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
endif
endif
endif
endif
endif

# From gmsl

# Standard definitions for true and false.  true is any non-empty
# string, false is an empty string. These are intended for use with
# $(if).

true  := T
false :=

# ----------------------------------------------------------------------------
# Function:  not
# Arguments: 1: A boolean value
# Returns:   Returns the opposite of the arg. (true -> false, false -> true)
# ----------------------------------------------------------------------------
not = $(if $1,$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  map
# Arguments: 1: Name of function to $(call) for each element of list
#            2: List to iterate over calling the function in 1
# Returns:   The list after calling the function on each element
# ----------------------------------------------------------------------------
map = $(strip $(foreach a,$2,$(call $1,$a)))

# ----------------------------------------------------------------------------
# Function:  seq
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are identical
# ----------------------------------------------------------------------------
seq = $(if $(filter-out xx,x$(subst $1,,$2)$(subst $2,,$1)x),$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  sne
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are not the same
# ----------------------------------------------------------------------------
sne = $(call not,$(call seq,$1,$2))

# End from gmsl

# Define comma symbol so we can repace it with a variable
comma :=,

# Signature
last_target :=

dump_var = $$(eval $1 := $($1))

define new_rule
@echo '$(call map,dump_var,@ < *)' > $S
@$(if $(wildcard $F),,touch $F)
@echo $@: $F >> $S
endef

define do
$(eval S := $(BLDDIR)/$*.sig)$(eval F := $(BLDDIR)/$*.force)$(eval C := $1)
$(if $(call sne,$@,$(last_target)),$(call new_rule),$(eval last_target := $@))
@echo '$$(if $$(call sne,$$(sort $1),$(sort $(subst $(comma),$$(comma),$C))),$$(shell touch $F))' >> $S
$Q$C
endef

# end of Signature


else # ifndef NO_SDK_DEPS
# No dependency files, faster compile times
# no partial compile support
DEPS_SED =
DEPS_OPT =
DEPS_CPY =
DEPS_CMD = /bin/true

define do
$(eval C := $1)
$Q$C
endef

endif

#
# Default Build rules for .c --> .o, leaving the binary in BLDDIR/X.o,
# even if file not built from directory of source.
#
ifeq ($(FAST),1)
${BLDDIR}/%.o: %.c
else
ifdef GENERATE_C_FILES
${BLDDIR}/%.o: %.c
else

${BLDDIR}/%.o: %.c
endif
endif
# echo Compiling needed to properly process errors 
	$Q$(MKDIR) $(BLDDIR)/
	$Q$(MKDIR) $(dir $@)
	$Q$(RM) -f $@
	@$Q$(ECHO) CCCC ${LOCALDIR}/$< 
# 55 is VERY different
ifeq ($(VX_VERSION),55)
	$Q$(CC) -M $(CFLAGS) $(EXTRA_CFLAGS)  $(realpath $<) > $(BLDDIR)/$*.d && ($(DEPS_CMD))
	$Q$(call do,$$(CC) $$(CFLAGS) $$(EXTRA_CFLAGS) -o $$@  -c $$(realpath $$<))
else
	$Q$(call do,$$(CC) $$(DEPS_OPT) $$(CFLAGS) $$(EXTRA_CFLAGS) -o $$@ -c $$(realpath $$<))  && ($(DEPS_CMD))
endif

${BLDDIR}/%.o: %.s
ifdef QUIET
	@$(ECHO) ASAS ${LOCALDIR}/$<
endif
	$Q$(CC) ${CFLAGS} ${EXTRA_CFLAGS} -o $@ -c $(realpath $<)

${BLDDIR}/%.o: %.cpp
ifdef QUIET
	@$(ECHO) CCCC ${LOCALDIR}/$<
endif
	$Q$(CXX) ${CXXFLAGS}  -o $@ -c $(realpath $<)

${BLDDIR}/%.o: %.cc ${BLDDIR}/.tree
ifdef QUIET
	@$(ECHO) CCCC ${LOCALDIR}/$<
endif
	$Q$(CXX) ${CXXFLAGS} -o $@ -c $(realpath $<)

#
# Cause "make foo.o" in any subdirectory to put the object in the build
# directory instead of the local directory.
#
%.o: ${BLDDIR}/%.o
	@

#
# Borland/NT
#
ifeq ($(TOOLS),Borland)
${BLDDIR}/%.obj: %.c
	bcc32 -D__BORLAND__ $(CFGFLAGS) \
		-I$(subst /,\,$(SDK)\include) \
		$(SYSINCLUDES) -o$@ -c $<
endif

#
# Java Support
#
JAVAC	= /bin/javac
JAVACFLAGS= -nowarn

${BLDDIR}/%.class: %.java
	$(JAVAC) ${JAVACFLAGS} -d ${BLDDIR} $<

%.Z: %
	@$(ECHO) COMPRESSING $< .....
	@$(COMPRESS) -c $< > $@

%.gz: %
	@$(ECHO) COMPRESSING $< .....
	@$(GZIP) -c $< > $@


#
# Some Basic tools
#
INSTALL = /usr/ucb/install
INSTALLFLAGS =
CTAGS   = ctags
ETAGS	= etags

#
# List of directories where built objects live.
# (we are not making the export directories for now)
#
#DIRS =	${BLDDIR} ${EXPDIR}/lib ${EXPDIR}/bin ${EXPDIR}/header
DIRS =	${BLDDIR}

#
# Targets for build
#
include ${SDK}/mk/Make.targets

ifeq (C_COMPILER,$(MAKECMDGOALS))
C_COMPILER:
	@echo $(CC)
endif

ifeq (CXX_COMPILER,$(MAKECMDGOALS))
CXX_COMPILER:
	@echo $(CXX)
endif

$(warn "MAKEFILE_LIST: $(MAKEFILE_LIST)")
#include ${SDK}/mk/Make.debug

#define DUMP_RULE
#	echo '$(1)';
#endef
#ifeq (DBG_MKEP,$(MAKECMDGOALS))
#DBG_MKEP: 
#	@echo '$(sort $(.VARIABLES))'
#	@echo 'fffffffffffff'
#	echo $(value BLDROOT)
#	$(if true, \
#			$(foreach v, $(sort $(.VARIABLES)), \
#			$(eval $(call DUMP_RULE,$(f)))) \
#			echo '')
#	@echo -e '\n\e[1;31m README\e[m'
#	@$(if true, \
#			$(foreach v, $(sort $(.VARIABLES)), \
#			$(eval MM_VV :=$(value $(v))) echo -e '\e[1;33m$(v)\e[m=$(MM_VV)';) \
#			echo '')
#	@echo -e '\n\e[1;31m README:above are all the value of variables(include make builtin) when execute this Makefile \e[m'
#$(foreach f,$(DELIVERABLES),$(eval $(call DELIVERY_RULE,$(f))))
#endif

#ifeq (DBG_MKNEP,$(MAKECMDGOALS))
#DBG_MKNEP:
#	@$(if true, \
#		$(foreach v, $(sort $(.VARIABLES)), \
#		$(eval $(call DUMP_RULE, $(v))))\
#		@echo '')
#endif



